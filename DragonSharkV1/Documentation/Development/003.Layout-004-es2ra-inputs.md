The contents of `es2ra-inputs` is this one:

```python3
#!/usr/bin/env python3
from __future__ import annotations

import re
import sys
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

ES_DEFAULT = Path.home() / ".emulationstation" / "es_input.cfg"
RA_AUTOCONFIG_DIR = Path.home() / ".config" / "retroarch" / "autoconfig" / "udev"

# ES logical -> RetroArch keys
ES_TO_RA_BUTTONS = {
    "a": "input_a_btn",
    "b": "input_b_btn",
    "x": "input_x_btn",
    "y": "input_y_btn",
    "start": "input_start_btn",
    "select": "input_select_btn",
    "hotkey": "input_enable_hotkey_btn",
    "pageup": "input_l_btn",
    "pagedown": "input_r_btn",
    "l1": "input_l_btn",
    "r1": "input_r_btn",
    "l2": "input_l2_btn",
    "r2": "input_r2_btn",
    "l3": "input_l3_btn",
    "r3": "input_r3_btn",
}

ES_TO_RA_AXES = {
    "leftanalogleft": "input_l_x_minus_axis",
    "leftanalogright": "input_l_x_plus_axis",
    "leftanalogup": "input_l_y_minus_axis",
    "leftanalogdown": "input_l_y_plus_axis",
    "rightanalogleft": "input_r_x_minus_axis",
    "rightanalogright": "input_r_x_plus_axis",
    "rightanalogup": "input_r_y_minus_axis",
    "rightanalogdown": "input_r_y_plus_axis",
}

DPAD_RA = {
    "up": "input_up_",
    "down": "input_down_",
    "left": "input_left_",
    "right": "input_right_",
}

@dataclass(frozen=True)
class InputDev:
    name: str
    vendor: Optional[str] = None  # hex like "045e"
    product: Optional[str] = None # hex like "028e"

def sanitize_filename(name: str) -> str:
    return re.sub(r"[^\w\s\-.()]+", "_", name).strip()

def parse_proc_bus_input_devices(path: Path = Path("/proc/bus/input/devices")) -> list[InputDev]:
    """
    Parses /proc/bus/input/devices and returns entries with Name + Vendor/Product.
    """
    if not path.exists():
        return []

    text = path.read_text(encoding="utf-8", errors="replace")
    blocks = re.split(r"\n\s*\n", text.strip(), flags=re.M)
    devs: list[InputDev] = []

    # Example lines:
    # I: Bus=0003 Vendor=045e Product=028e Version=0114
    # N: Name="Microsoft X-Box 360 pad"
    re_i = re.compile(r"^I:\s+.*Vendor=([0-9a-fA-F]{4}).*Product=([0-9a-fA-F]{4})", re.M)
    re_n = re.compile(r'^N:\s+Name="(.+)"', re.M)

    for b in blocks:
        mname = re_n.search(b)
        if not mname:
            continue
        name = mname.group(1).strip()

        mi = re_i.search(b)
        vendor = mi.group(1).lower() if mi else None
        product = mi.group(2).lower() if mi else None

        devs.append(InputDev(name=name, vendor=vendor, product=product))

    return devs

def find_vid_pid_for_name(dev_name: str, devs: list[InputDev]) -> tuple[Optional[str], Optional[str]]:
    """
    Best-effort match by exact name; if multiple match, return the first with VID/PID.
    """
    matches = [d for d in devs if d.name == dev_name]
    for d in matches:
        if d.vendor and d.product:
            return d.vendor, d.product
    return (matches[0].vendor, matches[0].product) if matches else (None, None)

def es_input_to_ra_value(inp_type: str, inp_id: str, inp_value: str) -> tuple[str, str] | None:
    if inp_type == "button":
        return ("btn", str(int(inp_id)))

    if inp_type == "axis":
        axis_id = int(inp_id)
        v = int(inp_value)
        return ("axis", f"-{axis_id}" if v < 0 else f"+{axis_id}")

    if inp_type == "hat":
        hat_id = int(inp_id)
        v = int(inp_value)
        bit_to_dir = {1: "up", 2: "right", 4: "down", 8: "left"}
        direction = bit_to_dir.get(v)
        if not direction:
            return None
        return ("hat", f"h{hat_id}{direction}")

    return None

def write_autoconfig(
    device_name: str,
    mappings: dict[str, str],
    out_dir: Path,
    vendor: Optional[str],
    product: Optional[str],
    guid: Optional[str],
) -> Path:
    out_dir.mkdir(parents=True, exist_ok=True)

    # Build a unique filename
    suffix_parts = []
    if vendor and product:
        suffix_parts.append(f"{vendor}-{product}")
    elif guid:
        suffix_parts.append(guid.lower())
    suffix = ("-" + "-".join(suffix_parts)) if suffix_parts else ""

    filename = sanitize_filename(device_name) + suffix + ".cfg"
    out_path = out_dir / filename

    lines = []
    lines.append('input_driver = "udev"')
    lines.append(f'input_device = "{device_name}"')
    lines.append(f'input_device_display_name = "{device_name}"')

    # Collision-proof matching:
    if vendor and product:
        lines.append(f'input_vendor_id = "0x{vendor}"')
        lines.append(f'input_product_id = "0x{product}"')

    for k, v in sorted(mappings.items()):
        lines.append(f'{k} = "{v}"')

    out_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    return out_path

def main() -> int:
    es_path = Path(sys.argv[1]) if len(sys.argv) > 1 else ES_DEFAULT
    if not es_path.exists():
        print(f"ERROR: EmulationStation config not found: {es_path}", file=sys.stderr)
        return 2

    proc_devs = parse_proc_bus_input_devices()

    tree = ET.parse(es_path)
    root = tree.getroot()

    written = 0
    for cfg in root.findall("inputConfig"):
        device_name = (cfg.attrib.get("deviceName") or "").strip()
        guid = (cfg.attrib.get("deviceGUID") or "").strip() or None
        if not device_name:
            continue

        vendor, product = find_vid_pid_for_name(device_name, proc_devs)

        ra_map: dict[str, str] = {}

        for inp in cfg.findall("input"):
            name = (inp.attrib.get("name") or "").strip().lower()
            inp_type = (inp.attrib.get("type") or "").strip().lower()
            inp_id = (inp.attrib.get("id") or "0").strip()
            inp_value = (inp.attrib.get("value") or "0").strip()

            # D-pad
            if name in DPAD_RA:
                converted = es_input_to_ra_value(inp_type, inp_id, inp_value)
                if not converted:
                    continue
                kind, value = converted
                ra_key_prefix = DPAD_RA[name]
                if kind == "btn":
                    ra_map[ra_key_prefix + "btn"] = value
                elif kind == "axis":
                    ra_map[ra_key_prefix + "axis"] = value
                elif kind == "hat":
                    ra_map[ra_key_prefix + "btn"] = value  # hats live in *_btn keys
                continue

            # Face/shoulders/etc
            if name in ES_TO_RA_BUTTONS:
                converted = es_input_to_ra_value(inp_type, inp_id, inp_value)
                if not converted:
                    continue
                kind, value = converted
                ra_key = ES_TO_RA_BUTTONS[name]
                if kind in ("btn", "hat"):
                    ra_map[ra_key] = value
                continue

            # Analog directions
            if name in ES_TO_RA_AXES:
                converted = es_input_to_ra_value(inp_type, inp_id, inp_value)
                if not converted:
                    continue
                kind, value = converted
                if kind == "axis":
                    ra_map[ES_TO_RA_AXES[name]] = value
                continue

        if ra_map:
            out = write_autoconfig(
                device_name=device_name,
                mappings=ra_map,
                out_dir=RA_AUTOCONFIG_DIR,
                vendor=vendor,
                product=product,
                guid=guid,
            )
            print(f"Wrote: {out}")
            written += 1

    if written == 0:
        print("No controllers converted (no <inputConfig> found or no mappings).", file=sys.stderr)
        return 1

    print(f"Done. Converted {written} controller profile(s).")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
```