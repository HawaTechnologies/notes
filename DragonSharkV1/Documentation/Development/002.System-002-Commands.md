# System Setup : Useful Commands

Commands described here relate to the process of developing and maintaining the image, and also for end users to some
extent (in-production useful commands for end users).

## Install, backup and restore

The following commands can be used to create the initial installation of the console, a backup of the console, and also
a restore of a backup into the console. These commands assume certain names or indices, so users must double-check
everything before executing them, or they might lose their data and have to start over.

This works with any image compatible with the ARM64 architecture for Banana Pi M5 but, for the sake of this console, it
must be the Raspbian Image described in [this page](002.System-001-OS-Structure.md).

### Install

This instruction is related to Armbian systems and only works on the fresh install (for development purposes - use the
Restore method when installing a Dragonshark OS image, instead, on a new Banana Pi BPI M5 device).

```shell
sudo armbian-install
```

Follow all the instructions.

### Restore

The instructions here are the same whether it's a first install or it's a restore over an existing install (full wipe
of the existing system).

First, install requires an external SD card to be burned with the image to use (development or production, it doesn't
matter by this point). By this point, nothing is burned in the eMMC and, in fact, that's the goal of this step.

The first thing to do is recognize the available storage devices:

```shell
fdisk -l
```

Showing like this:

```
Disk /dev/mmcblk0: ...storage size info...
Units: ...
Sector size (logical/physical): ...
I/O size (minimum/optimal): ...
Disklabel type: ...
Disk identifier: ...

Device Boot Start End Sectors Size Id  Type
...    ...  ...   ... ...     ...  ... ...

Disk /dev/mmcblk1: ...storage size info...
Units: ...
Sector size (logical/physical): ...
I/O size (minimum/optimal): ...
Disklabel type: ...
Disk identifier: ...

Device Boot Start End Sectors Size Id  Type
...    ...  ...   ... ...     ...  ... ...
```

_Two_ disks, one standing for the SD card and one for the internal disk. Check the sizes, considering the eMMC has
almost 16 GB of storage, and the SD card will vary (you might notice other details, especially if the SD card has
also almost 16 GB of storage: check which unit has a big bunch of used space, and that one will be the SD card -
however, typically the `/dev/mmcblk0` will be the SD card by this point, since the system was booted from the SD
card).

With this in mind, it's just a matter of burning the current SD card system into the eMMC, like this:

```shell
sudo dd if=/dev/mmcblk0 of=/dev/mmcblk1 bs=4M status=progress
```

_Double check this, since I'm assuming `/dev/mmcblk0` stands for the SD Card and `/dev/mmcblk1` stands for the
eMMC device_.

Alternatively, if the SD card is big enough and has more things and more partitions, perhaps it's the case for
an image to exist by this point, inside one or more of the partitions. For example, let's say that the SD card
has a partition named `/media/pi/BigOne` with an image file named `mmcblk0_backup.img` having the system to be
installed. This command, in that situation, works:

```shell
sudo dd if=/media/pi/BigOne/mmcblk0_backup.img of=/dev/mmcblk1 bs=4M status=progress
```

_Again: Double check this, since I'm assuming `/dev/mmcblk0` stands for the SD Card and `/dev/mmcblk1` stands
for the eMMC device_.

Finally, that command can also be done if not starting from the SD card! It's somewhat risky to do this, since
the device being written in this case is the eMMC while, at the same time, the eMMC is running its own system
and writing its own files, and something might be corrupted in the middle. **Do this with caution**. The command
is the same one, but for `/dev/mmcblk0`.

```shell
sudo dd if=/media/pi/BigOne/mmcblk0_backup.img of=/dev/mmcblk0 bs=4M status=progress
```

With this, the next step to have this working is:

1. Shutdown the console (e.g. unplug, or gracefully shut down the OS).
2. Remove the SD card.
3. Start the console.

The new system should be working. The structure of the storage in the eMMC will look like this for a bare image:

```
mmcblk0 (disk)
+-mmcblk0p1 (part, 256mb) /boot (ext4)
+-mmcblk0p2 (part, ...gb) / (ext4)
mmcblk0boot0 (disk)
mmcblk0boot1 (disk)
mmcblk0rpmb (disk)
```

For a DragonShark image already being worked on (which has a Raspbian base system as described), two partitions
can be seen as additional ones inside `mmcblk0`:

```
+-mmcblk0p3 (part, 1mb) /mnt/CURRENT_SAVE (ext4)
+-mmcblk0p4 (part, 1.2gb) /mnt/SAVES (ext4)
```

Creating these partitions is explained in the next section, but typically not needed when starting with the said
DragonShark image.

### Additional partitions

Two additional partitions are needed here. This must be created only if they do not exist (and this typically
only occurs when the source image is not a DragonShark-related / to-restore image but a very bare image the
user downloaded to work everything from scratch).

Two partitions are needed here: /mnt/SAVES and /mnt/CURRENT_SAVE. The former serves to store all the saves,
both for emulated games and native games. The latter is only used by the currently executing native game.

This is done by running `parted` and ensuring these partitions exist:

```
+-mmcblk0p3 (part, 1mb) /mnt/CURRENT_SAVE (ext4)
+-mmcblk0p4 (part, 1.2gb) /mnt/SAVES (ext4)
```

Which means:

1. At least 1 GB for the `/mnt/CURRENT_SAVE` partition and _exactly that name_.
   Using a lower size will limit the ability for games to store themselves. This
   is particularly true for web games, whose saves might be big, depending on the
   game (but, yes: browsers might store a lot there).
2. At least 1.2 GB for `/mnt/SAVES` partition and _exactly that name_. This might
   be changed, since it's not needed to have that amount of saves. While ARM64
   games and emulated games perhaps take a very small space, web games will take,
   most likely, more space. So choose a sensible size for this partition.

### Backup

The backup is the converse operation. It is only needed:

1. A system to exist in the eMMC storage.
2. The target SD card in the SD card slot, with enough AVAILABLE space (same size of
   the eMMC).

Assuming the SD card is mounted at `/media/pi/BigOne`, then the commands are:

```shell
sudo dd if=/dev/mmcblk0 of=/media/pi/BigOne/mmcblk0_backup.img bs=4M status=progress
# These 3 might be not necessary, but anyway I'm adding them.
sudo dd if=/dev/mmcblk0boot0 of=/media/pi/BigOne/mmcblk0boot0_backup.img bs=4M status=progress
sudo dd if=/dev/mmcblk0boot1 of=/media/pi/BigOne/mmcblk0boot1_backup.img bs=4M status=progress
sudo dd if=/dev/mmcblk0rpmb of=/media/pi/BigOne/mmcblk0rpmb_backup.img bs=4M status=progress
```

## Creating and maintaining users

The commands to create the `gamer` user were:

```shell
# 1. Create the "gamer" user, with exactly that name.
sudo useradd -M gamer

# 2. Link it to /mnt/CURRENT_SAVE. This storage must exist by this point.
sudo ln -s /mnt/CURRENT_SAVE /home/gamer

# 3. Add it to the audio users.
sudo usermod -aG audio gamer
```

Also, in order to change the password for the existing `root` and `pi` users:

1. `sudo passwd` for `root` user.
2. `GUI option: Start > Preferences > Raspberry Pi Configuration` for `pi` user.
    1. Button: `Change Password`.

The default password that comes with the supported image is: `Admin$2024`.

For the `pi` user in particular, ensuring it's auto-logged-in is mandatory:

```shell
sudo nano /etc/lightdm/lightdm.conf
```

And filling the contents:

```shell
[Seat:*]
autologin-user=pi
autologin-user-timeout=0
```
